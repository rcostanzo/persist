// $Id$

package net.sf.persist;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Holds mapping data from a given class and a table
 */
public final class AnnotationTableMapping extends Mapping {

    private static final Logger ENGINE_LOG = LoggerFactory.getLogger("persist.engine");

    private final Class<?> objectClass;

    private final net.sf.persist.annotations.Table tableAnnotation;
    private final String tableName;

    private final String[] fields; // list of fields which have getters and setters
    private final Map<String, net.sf.persist.annotations.Column> annotationsMap; // maps field names to annotations
    private final Map<String, Method> gettersMap; // maps field names to getters
    private final Map<String, Method> settersMap; // maps field names to setters

    private final Map<String, String> columnsMap = new LinkedHashMap<>(); // maps table columns to property names
    private final String[] columns;
    private final String[] primaryKeys;
    private final String[] notPrimaryKeys;
    private final String[] autoGeneratedColumns;
    private final String[] notAutoGeneratedColumns;

    private final String selectSql;
    private final String selectAllSql;
    private final String insertSql;
    private final String updateSql;
    private final String deleteSql;

    public AnnotationTableMapping(final Class<?> objectClass) {

        // object class
        this.objectClass = objectClass;

        // table annotation
        tableAnnotation = objectClass.getAnnotation(net.sf.persist.annotations.Table.class);

        if (tableAnnotation == null || tableAnnotation.name() == null) {
            throw new PersistException("Class missing @Table annotation or table name: " + objectClass.getName());
        }

        // table name from annotation
        tableName = tableAnnotation.name();

        // map field names to annotations, getters and setters
        final Map[] fieldsMaps = getFieldsMaps(objectClass);
        annotationsMap = fieldsMaps[0];
        gettersMap = fieldsMaps[1];
        settersMap = fieldsMaps[2];
        fields = toArray(gettersMap.keySet());

        // map column names to field names; create list of auto-increment columns
        // columnsMap use keys in lower case

        // the actual autoGeneratedColumns list should have columns in the database order
        final List<String> primaryKeysList = new ArrayList<>();
        final List<String> notPrimaryKeysList = new ArrayList<>();
        final List<String> columnsList = new ArrayList<>();
        final Set<String> autoGeneratedColumnsTemp = new HashSet<>();

        for (String fieldName : fields) {
            final net.sf.persist.annotations.Column annotation = annotationsMap.get(fieldName);
            final String columnName = annotation.name();
            columnsList.add(columnName);

            // primary keys
            if (annotation.primaryKey()) {
                primaryKeysList.add(columnName);
            } else {
                notPrimaryKeysList.add(columnName);
            }

            columnsMap.put(columnName.toLowerCase(Locale.ENGLISH), fieldName);
            if (annotation != null && annotation.autoGenerated()) {
                autoGeneratedColumnsTemp.add(columnName);
            }

        }

        if (primaryKeysList.isEmpty()) {
            ENGINE_LOG.warn("No primary keys annotated. Any update, delete, or readByPrimaryKey calls will not work.");
        }

        columns = toArray(columnsList);
        primaryKeys = toArray(primaryKeysList);
        notPrimaryKeys = toArray(notPrimaryKeysList);

        // auto-increment and not-auto-increment columns

        final List<String> notAutoGeneratedColumnsList = new ArrayList<>();
        final List<String> autoGeneratedColumnsList = new ArrayList<>();
        for (String columnName : columns) {
            if (autoGeneratedColumnsTemp.contains(columnName)) {
                autoGeneratedColumnsList.add(columnName);
            } else {
                notAutoGeneratedColumnsList.add(columnName);
            }
        }
        notAutoGeneratedColumns = toArray(notAutoGeneratedColumnsList);
        autoGeneratedColumns = toArray(autoGeneratedColumnsList);

        // assemble sql blocks to be used by crud sql statements

        final String allColumns = join(columns, "", ",");
        final String noAutoColumns = join(notAutoGeneratedColumns, "", ",");
        final String allPlaceholders = multiply("?", columns.length, ",");
        final String noAutoPlaceholders = multiply("?", notAutoGeneratedColumns.length, ",");
        final String where = join(primaryKeys, "=?", " and ");
        final String updateSet = join(notPrimaryKeys, "=?", ",");

        // assemble crud sql statements

        selectSql = "select " + allColumns + " from " + tableName + " where " + where;
        selectAllSql = "select " + allColumns + " from " + tableName;

        if (autoGeneratedColumns.length == 0) {
            insertSql = "insert into " + tableName + "(" + allColumns + ") values (" + allPlaceholders + ")";
        } else {
            insertSql = "insert into " + tableName + "(" + noAutoColumns + ") values (" + noAutoPlaceholders + ")";
        }

        updateSql = "update " + tableName + " set " + updateSet + " where " + where;
        deleteSql = "delete from " + tableName + " where " + where;

    }

    // ---------- getters and setters ----------

    public Class<?> getObjectClass() {
        return objectClass;
    }

    public String getTableName() {
        return tableName;
    }

    public net.sf.persist.annotations.Table getTableAnnotation() {
        return tableAnnotation;
    }

    public String[] getColumns() {
        return columns;
    }

    public Map<String, String> getColumnsMap() {
        return columnsMap;
    }

    public String[] getPrimaryKeys() {
        return primaryKeys;
    }

    public String[] getNotPrimaryKeys() {
        return notPrimaryKeys;
    }

    public String[] getAutoGeneratedColumns() {
        return autoGeneratedColumns;
    }

    public String[] getNotAutoGeneratedColumns() {
        return notAutoGeneratedColumns;
    }

    public String[] getFields() {
        return fields;
    }

    public Map<String, net.sf.persist.annotations.Column> getAnnotationsMap() {
        return annotationsMap;
    }

    public Map<String, Method> getGettersMap() {
        return gettersMap;
    }

    public Map<String, Method> getSettersMap() {
        return settersMap;
    }

    @Override
    public Method getGetterForColumn(final String columnName) {
        final Optional<String> fieldName = Optional.ofNullable(columnsMap.get(columnName.toLowerCase(Locale.ENGLISH)));
        if (!fieldName.isPresent()) {
            throw new NoSuchElementException(
                "Could not find field name corresponding to column name [" + columnName + "]");
        }
        final Optional<Method> getterForFieldName = Optional.ofNullable(gettersMap.get(fieldName.get()));
        if (!getterForFieldName.isPresent()) {
            throw new NoSuchElementException("Could not find getter for columnn with field name [" + fieldName + "]");
        }
        return getterForFieldName.get();
    }

    @Override
    public Method getSetterForColumn(final String columnName) {
        final Optional<String> fieldName = Optional.ofNullable(columnsMap.get(columnName.toLowerCase(Locale.ENGLISH)));
        if (!fieldName.isPresent()) {
            throw new NoSuchElementException(
                "Could not find field name corresponding to column name [" + columnName + "]");
        }
        final Optional<Method> setterForFieldName = Optional.ofNullable(settersMap.get(fieldName.get()));
        if (!setterForFieldName.isPresent()) {
            throw new NoSuchElementException("Could not find setter for columnn with field name [" + fieldName + "]");
        }
        return setterForFieldName.get();
    }

    public String getSelectSql() {
        return selectSql;
    }

    public String getSelectAllSql() {
        return selectAllSql;
    }

    public String getInsertSql() {
        return insertSql;
    }

    public String getUpdateSql() {
        return updateSql;
    }

    public String getDeleteSql() {
        return deleteSql;
    }

    @Override
    public Class<?> getOptionalSubType(final String columnName) {
        final Optional<String> fieldName = Optional.ofNullable(columnsMap.get(columnName.toLowerCase(Locale.ENGLISH)));
        if (!fieldName.isPresent()) {
            throw new NoSuchElementException(
                "Could not find field name corresponding to column name [" + columnName + "]");
        }
        final Optional<Class<?>> optSubTypeForFieldName =
            Optional.ofNullable(annotationsMap.get(fieldName.get()).optionalSubType());
        if (!optSubTypeForFieldName.isPresent()) {
            throw new NoSuchElementException(
                "Could not find optional subtype for columnn with field name [" + fieldName + "]");
        }
        return optSubTypeForFieldName.get();
    }

    // ---------- helpers ----------

    private static String[] toArray(final List<String> list) {
        String[] array = new String[list.size()];
        for (int i = 0; i < list.size(); i++) {
            array[i] = list.get(i);
        }
        return array;
    }

    private static String[] toArray(final Set<String> set) {
        final String[] array = new String[set.size()];
        int i = 0;
        for (String s : set) {
            array[i] = s;
            i++;
        }
        return array;
    }

    private static String join(final String[] list, final String suffix, final String separator) {
        final StringBuffer buf = new StringBuffer();
        for (String obj : list) {
            buf.append(obj.toString()).append(suffix).append(separator);
        }
        if (buf.length() > 0 && separator.length() > 0) {
            buf.delete(buf.length() - separator.length(), buf.length());
        }
        return buf.toString();
    }

    private static String multiply(final String str, final int times, final String separator) {
        final StringBuffer buf = new StringBuffer();
        for (int i = 0; i < times; i++) {
            buf.append(str).append(separator);
        }
        if (separator.length() > 0) {
            buf.delete(buf.length() - separator.length(), buf.length());
        }
        return buf.toString();
    }

}
